import socket
import re
import subprocess
from datetime import datetime
from utils.real_vuln_db import RealVulnDatabase, get_offline_vulnerabilities

class VulnerabilityScanner:
    def __init__(self, ip, open_ports=None, services=None, os_info=None):
        self.ip = ip
        self.open_ports = open_ports or []
        self.services = services or {}
        self.os_info = os_info or {}
        self.vulnerabilities = []
        self.risk_score = 0
        self.risk_level = 'Low'
        
    def scan_vulnerabilities(self):
        """Main vulnerability scanning function"""
        # Check for dangerous open ports
        self.check_dangerous_ports()
        
        # Check for outdated/vulnerable services
        self.check_service_vulnerabilities()
        
        # Check for weak configurations
        self.check_misconfigurations()
        
        # Check for anonymous access
        self.check_anonymous_access()
        
        # Calculate risk score
        self.calculate_risk()
        
        return {
            'ip': self.ip,
            'vulnerabilities': self.vulnerabilities,
            'total_vulnerabilities': len(self.vulnerabilities),
            'risk_score': self.risk_score,
            'risk_level': self.risk_level,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
    
    def add_vulnerability(self, severity, title, description, cve=None, port=None, recommendation=None, category='Unknown', cvss_score=None, source='Local Detection'):
        """Add a vulnerability to the list"""
        vuln = {
            'severity': severity,  # Critical, High, Medium, Low, Info
            'title': title,
            'description': description,
            'cve': cve,
            'port': port,
            'category': category,
            'cvss_score': cvss_score,
            'source': source,
            'recommendation': recommendation or 'Review and patch this vulnerability'
        }
        self.vulnerabilities.append(vuln)
        
        # Add to risk score
        score_map = {'Critical': 10, 'High': 7, 'Medium': 4, 'Low': 2, 'Info': 1}
        self.risk_score += score_map.get(severity, 0)
    
    def check_dangerous_ports(self):
        """Check for dangerous/uncommon open ports"""
        dangerous_ports = {
            21: ('FTP - Unencrypted File Transfer', 'Medium', 
                 'FTP transmits credentials in plain text. Use SFTP (port 22) instead.'),
            23: ('Telnet - Unencrypted Remote Access', 'High',
                 'Telnet is completely unencrypted. Use SSH (port 22) instead.'),
            69: ('TFTP - Trivial FTP (No Authentication)', 'High',
                 'TFTP has no authentication. Close this port if not needed.'),
            135: ('MS-RPC - Windows RPC Endpoint Mapper', 'Medium',
                  'CVE-2003-0352, CVE-2005-0051. Keep Windows updated.'),
            139: ('NetBIOS Session Service', 'Medium',
                  'Can leak system information. Block from internet.'),
            445: ('SMB - File Sharing', 'High',
                  'EternalBlue (CVE-2017-0144), SMBGhost (CVE-2020-0796). Update immediately!'),
            1433: ('MS-SQL Server', 'High',
                   'SQL Server exposed. Use firewall and strong passwords.'),
            3306: ('MySQL Database', 'High',
                   'Database exposed. Restrict access and use strong passwords.'),
            3389: ('RDP - Remote Desktop', 'Critical',
                   'BlueKeep (CVE-2019-0708), DejaBlue. Enable NLA and update Windows!'),
            5432: ('PostgreSQL Database', 'High',
                   'Database exposed. Restrict access and use strong authentication.'),
            5900: ('VNC - Remote Desktop', 'High',
                   'Often uses weak passwords. Use SSH tunnel instead.'),
            6379: ('Redis - In-Memory Database', 'Critical',
                   'Often misconfigured without authentication. Set requirepass!'),
            8080: ('HTTP Proxy/Alt Web Server', 'Medium',
                   'May expose admin panels. Ensure proper authentication.'),
            27017: ('MongoDB Database', 'Critical',
                    'CVE-2017-2665. Often exposed without authentication!'),
        }
        
        for port in self.open_ports:
            if port in dangerous_ports:
                title, severity, desc = dangerous_ports[port]
                self.add_vulnerability(
                    severity=severity,
                    title=f'Dangerous Port Open: {port} ({title})',
                    description=desc,
                    port=port,
                    recommendation=f'Close port {port} or restrict access via firewall'
                )
    
    def check_service_vulnerabilities(self):
        """Check for known vulnerable service versions using REAL online CVE database"""
        # Initialize real vulnerability database
        vuln_db = RealVulnDatabase()
        
        # Check each service detected
        for port, service_info in self.services.items():
            # Handle both string and dict format
            if isinstance(service_info, dict):
                service_banner = service_info.get('banner', '')
            elif isinstance(service_info, str):
                service_banner = service_info
            else:
                continue
            
            if not service_banner or service_banner == 'Unknown':
                continue
            
            # Extract product name and version from banner
            service_data = vuln_db.extract_service_info(service_banner)
            
            if service_data:
                product = service_data['product']
                version = service_data['version']
                
                print(f"[*] Querying CVE database for {product} {version}...")
                
                # Try online database first
                online_vulns = vuln_db.search_cve_by_cpe(product, version)
                
                # Also check offline database as fallback
                offline_vulns = get_offline_vulnerabilities(product, version)
                
                # Combine results
                all_vulns = online_vulns + offline_vulns
                
                # Remove duplicates based on CVE ID
                seen_cves = set()
                unique_vulns = []
                for vuln in all_vulns:
                    cve_id = vuln.get('cve', 'Unknown')
                    if cve_id not in seen_cves:
                        seen_cves.add(cve_id)
                        unique_vulns.append(vuln)
                
                # Add each vulnerability to results
                for vuln in unique_vulns:
                    self.add_vulnerability(
                        category='Service Vulnerability',
                        severity=vuln.get('severity', 'Medium'),
                        title=f"{vuln.get('cve', 'N/A')} - {product.title()} {version}",
                        description=vuln.get('description', 'No description'),
                        port=port,
                        cve=vuln.get('cve'),
                        cvss_score=vuln.get('cvss_score'),
                        recommendation=vuln.get('recommendation', f'Update {product} to latest version'),
                        source=vuln.get('source', 'Unknown')
                    )
                
                # If vulnerabilities found, log success
                if unique_vulns:
                    print(f"[+] Found {len(unique_vulns)} CVEs for {product} {version}")
                else:
                    print(f"[i] No known CVEs found for {product} {version}")
        
        # Keep offline pattern matching as fallback for services without version info
        self._check_offline_patterns()
    
    def _check_offline_patterns(self):
        """Fallback: Check using offline pattern matching for services without clear version"""
        # Known vulnerable patterns
        vulnerable_services = [
            # Apache
            {
                'pattern': r'Apache/2\.[0-2]\.',
                'severity': 'High',
                'title': 'Outdated Apache HTTP Server',
                'description': 'Apache 2.0-2.2 has multiple CVEs including CVE-2021-41773 (Path Traversal)',
                'cve': 'CVE-2021-41773',
                'recommendation': 'Upgrade to Apache 2.4.51 or later'
            },
            # nginx
            {
                'pattern': r'nginx/1\.[0-9]\.',
                'severity': 'Medium',
                'title': 'Potentially Outdated nginx',
                'description': 'nginx 1.x may have known vulnerabilities',
                'recommendation': 'Update to latest stable nginx version'
            },
            # OpenSSH
            {
                'pattern': r'OpenSSH[_/]([0-6]\.|7\.[0-3])',
                'severity': 'Critical',
                'title': 'Vulnerable OpenSSH Version',
                'description': 'OpenSSH < 7.4 vulnerable to multiple CVEs including user enumeration',
                'cve': 'CVE-2016-6210',
                'recommendation': 'Upgrade OpenSSH to version 8.0 or later'
            },
            # Microsoft IIS
            {
                'pattern': r'IIS/[6-7]\.',
                'severity': 'High',
                'title': 'Outdated IIS Server',
                'description': 'IIS 6.0-7.5 has multiple known vulnerabilities',
                'recommendation': 'Upgrade to IIS 10.0 or later (Windows Server 2016+)'
            },
            # ProFTPD
            {
                'pattern': r'ProFTPD 1\.[0-2]\.',
                'severity': 'Critical',
                'title': 'ProFTPD Backdoor/Command Execution',
                'description': 'ProFTPD 1.3.3c had backdoor (CVE-2010-4221)',
                'cve': 'CVE-2010-4221',
                'recommendation': 'Upgrade to latest ProFTPD version'
            },
            # vsftpd
            {
                'pattern': r'vsftpd 2\.3\.4',
                'severity': 'Critical',
                'title': 'vsftpd Backdoor Vulnerability',
                'description': 'vsftpd 2.3.4 contains a backdoor (CVE-2011-2523)',
                'cve': 'CVE-2011-2523',
                'recommendation': 'Upgrade vsftpd immediately or switch to SFTP'
            },
            # Samba
            {
                'pattern': r'Samba [0-3]\.',
                'severity': 'Critical',
                'title': 'Vulnerable Samba Version',
                'description': 'Samba 3.x has critical RCE vulnerabilities (SambaCry CVE-2017-7494)',
                'cve': 'CVE-2017-7494',
                'recommendation': 'Upgrade to Samba 4.6.4 or later'
            },
        ]
        
        for port, service_info in self.services.items():
            service_banner = service_info.get('banner', '') if isinstance(service_info, dict) else str(service_info)
            
            for vuln in vulnerable_services:
                if re.search(vuln['pattern'], service_banner, re.IGNORECASE):
                    self.add_vulnerability(
                        category='Service Vulnerability',
                        severity=vuln['severity'],
                        title=vuln['title'],
                        description=vuln['description'],
                        cve=vuln.get('cve'),
                        port=port,
                        recommendation=vuln['recommendation']
                    )
    
    def check_misconfigurations(self):
        """Check for common misconfigurations"""
        
        # SMB + No authentication (Port 445 + 139)
        if 445 in self.open_ports or 139 in self.open_ports:
            self.add_vulnerability(
                severity='High',
                title='SMB Service Detected - EternalBlue Risk',
                description='SMB has been exploited by WannaCry, NotPetya via EternalBlue exploit. Ensure SMBv1 is disabled.',
                cve='CVE-2017-0144',
                port=445,
                recommendation='Disable SMBv1, enable SMB signing, keep Windows updated'
            )
        
        # RDP on default port
        if 3389 in self.open_ports:
            self.add_vulnerability(
                severity='Critical',
                title='RDP Exposed on Default Port',
                description='RDP on port 3389 is commonly attacked. BlueKeep and other RDP vulnerabilities are actively exploited.',
                cve='CVE-2019-0708',
                port=3389,
                recommendation='Use VPN, change default port, enable Network Level Authentication (NLA), keep Windows updated'
            )
        
        # Multiple databases exposed
        db_ports = [3306, 5432, 1433, 27017, 6379]
        exposed_dbs = [p for p in self.open_ports if p in db_ports]
        if exposed_dbs:
            self.add_vulnerability(
                severity='Critical',
                title='Database Server Exposed to Network',
                description=f'Database ports {exposed_dbs} are accessible. This can lead to data breaches.',
                port=exposed_dbs[0],
                recommendation='Restrict database access to localhost or specific IPs via firewall'
            )
        
        # Web server + Database on same host
        web_ports = [80, 443, 8080, 8443]
        if any(p in self.open_ports for p in web_ports) and any(p in self.open_ports for p in db_ports):
            self.add_vulnerability(
                severity='Medium',
                title='Web Server and Database on Same Host',
                description='Having web server and database on the same machine increases attack surface.',
                recommendation='Consider separating web server and database to different machines'
            )
        
        # FTP + Anonymous access check
        if 21 in self.open_ports:
            if self.check_anonymous_ftp():
                self.add_vulnerability(
                    severity='High',
                    title='Anonymous FTP Access Enabled',
                    description='FTP allows anonymous login without password. Anyone can access files.',
                    port=21,
                    recommendation='Disable anonymous FTP or switch to SFTP'
                )
    
    def check_anonymous_ftp(self):
        """Check if FTP allows anonymous access"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.connect((self.ip, 21))
            
            # Read banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            
            # Try anonymous login
            sock.send(b'USER anonymous\r\n')
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            sock.send(b'PASS anonymous@\r\n')
            response2 = sock.recv(1024).decode('utf-8', errors='ignore')
            
            sock.close()
            
            # Check if login successful (230 code)
            if '230' in response2:
                return True
        except:
            pass
        
        return False
    
    def check_anonymous_access(self):
        """Check for services with anonymous/guest access"""
        
        # Telnet (often no password on IoT devices)
        if 23 in self.open_ports:
            self.add_vulnerability(
                severity='Critical',
                title='Telnet Service Enabled',
                description='Telnet transmits everything in plaintext including passwords. Often has default credentials on IoT devices.',
                port=23,
                recommendation='Disable Telnet and use SSH instead'
            )
        
        # VNC (often weak/no password)
        if 5900 in self.open_ports:
            self.add_vulnerability(
                severity='High',
                title='VNC Remote Desktop Exposed',
                description='VNC authentication is weak and passwords limited to 8 characters. Often found with no password.',
                port=5900,
                recommendation='Use SSH tunneling for VNC or switch to more secure remote desktop solution'
            )
        
        # Redis (often no auth)
        if 6379 in self.open_ports:
            self.add_vulnerability(
                severity='Critical',
                title='Redis Exposed Without Authentication',
                description='Redis is often deployed without authentication (requirepass). Attackers can read/write data or execute commands.',
                cve='CVE-2015-4335',
                port=6379,
                recommendation='Set requirepass in redis.conf and bind to localhost only'
            )
        
        # MongoDB (historically no auth by default)
        if 27017 in self.open_ports:
            self.add_vulnerability(
                severity='Critical',
                title='MongoDB Exposed to Network',
                description='MongoDB was historically deployed without authentication. Many databases are exposed and ransomed.',
                port=27017,
                recommendation='Enable authentication, bind to localhost, use firewall rules'
            )
    
    def calculate_risk(self):
        """Calculate overall risk level"""
        if self.risk_score >= 30:
            self.risk_level = 'Critical'
        elif self.risk_score >= 20:
            self.risk_level = 'High'
        elif self.risk_score >= 10:
            self.risk_level = 'Medium'
        elif self.risk_score >= 5:
            self.risk_level = 'Low'
        else:
            self.risk_level = 'Info'
        
        # Add summary vulnerability
        if self.vulnerabilities:
            severity_count = {}
            for v in self.vulnerabilities:
                sev = v['severity']
                severity_count[sev] = severity_count.get(sev, 0) + 1
            
            summary = f"Found {len(self.vulnerabilities)} potential issues: "
            summary += ", ".join([f"{count} {sev}" for sev, count in severity_count.items()])
            
            # Insert summary at beginning
            self.vulnerabilities.insert(0, {
                'severity': 'Info',
                'title': 'Security Scan Summary',
                'description': summary,
                'cve': None,
                'port': None,
                'recommendation': 'Review all findings below and prioritize Critical/High severity issues'
            })

def scan_vulnerabilities(ip, open_ports=None, services=None, os_info=None):
    """Main function to scan vulnerabilities"""
    scanner = VulnerabilityScanner(ip, open_ports, services, os_info)
    return scanner.scan_vulnerabilities()
